В данной главе приводится описание выбранных методов, моделей, алгоритмов решения задач.
Во-первых описывается общая трехкомпонентная архитектура программы.
Во-вторых с аппаратной точки зрения описываются платформы на которых будут исполнятся компоненты программы.
В-третьих описывается архитектура каждого компонента и их модулей.
В-четвертых описывается модель взаимодействия между модулями внутри каждого компонента.
В-пятых описывается модель взаимодействия между тремя компонентами программы.

\subsection{ Архитектура программы }
Программа имеет трехкомпонентную архитектуру. Первым компонентом является прошивка, устанавливаемая на РВ-90. Второй компонент представляет собой одно-страничное веб-приложение, которое будет храниться во флеш-памяти вместе с прошивкой, передаваться на устройство пользователя при подключении и запускаться в браузере. Третий компонент - это Android-приложение, которое может быть установлено на устройстве пользователя через Google Play. Каждый компонент создается с использованием своего стека технологий. Таким образом, программа состоит из трех отдельных компонентов, которые должны быть разработаны отдельно и должны будут взаимодействовать друг с другом. 

Одним из основных факторов успеха мобильного приложения является простота его  распространения.  В связи с этим была выбрана мобильная операционная система  Android – самая распространенная мобильная операционная система для смартфонов, имеющая долю рынка около 80\%.
 
Конструкция аппаратной базы для РВ-90 является фиксированной и должна учитываться при проектировании архитектуры программы

\textbf{Три платформы}
\begin{my_itemize}
\item РВ-90
\item Браузер
\item Android
\end{my_itemize}


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{three_platforms.png}
    \caption{Диаграмма взаимодействия между реле и клиентом.}
\end{figure}



%===========================================================================



\newpage
\subsection{ Платформа РВ-90 }
Аппаратная база представлена в виде устройства РВ-90. Нет смысла рассматривать абсолютно все физические характеристики устройства. Далее будут рассмотрены те из них, которые влияют на реализацию программы. В основе устройства находится модуль RAK473. К GPIO вводам которого подключены: 3 пина для программирования (SWDIO, SWCLK, RST), 2 пина для взаимодействия через UART (RX, TX), питание 5 вольт, земля, шина I2C. К шине I2C подключены часы реального времени DS1307 и I2C расширитель портов PCA9555. К GPIO выводам расширителя подключены 4 светодиода, 3 push-down кнопки, 2 реле RT424005.
Выбор компонентов влияет на архитектуру программы. В данной секции в больших деталях рассмотрены некоторые компоненты РВ-90 и их аналоги с целью понимания специфики каждого компонента. 

\subsubsection{ Кнопки на корпусе РВ-90 }
На корпусе имеются 3 кнопки, 2 из них для ручного переключения состояния каждого из двух реле, и одна для жесткой перезагрузки системы.
Кнопки не используют пин прерывания имеющийся у I2C расширителя портов RCA9555 для оповещения об изменении своего состояния. Программа должна периодически опрашивать текущее напряжение на кнопках, чтобы заметить нажатие. По умолчанию линии кнопок притянуты вверх, поэтому напряжение уровня земли соответствует нажатию. Программа должна применять фильтр к данным о состоянии кнопок, чтобы исключить ложные срабатывания, а также и двойные/тройные срабатывания из-за дребезжания контактов. 

\subsubsection{ I2C расширитель портов PCA9555} 
Выбор I2C расширителя портов PCA9555 обоснован его низкой ценой и расширением на 16 GPIO портов, которых более чем хватает для контроля аналоговой периферии. Выбор также обусловлен возможностью задать I2C адрес для расширителя на этапе производства устройства, чтобы избежать конфликта адресов на шине. В качестве аналога существует более дешевый PCA9554 предоставляющий расширение на 8 GPIO портов и имеющий жестко зафиксированный адрес на шине. 

\subsubsection{ Часы реального времени DS1374}
Выбор часов реального времени DS1374 имеет недостаток в виде высокой цены и много достоинств. 
Для взаимодействия с микроконтроллером данные часы используют протокол I2C, вместе с другой периферией их можно подключить к общей шине I2C, что очень важно в условиях ограниченного количества GPIO пинов  микроконтроллера.
Данные часы отсчитывают время в формате Unix-time. Формат Unix-time удобен для хранения, сравнения и передачи. Поскольку подразумевается что пользователь может создавать много событий включения/выключения требующих хранения времени, а память в системе ограничена, то важно иметь компактный формат для хранения времени. При взаимодействии с пользователем и при работе программы временные значения будут часто передаваться между различными программными модулями, важно что формат Unix-time очень прост в представлении и следовательно удобен для передачи. При принятии решений система должна уметь возможность сравнивать и считать разницу между двумя временными значениями, время в формате Unix-time можно удобно и быстро сравнивать между собой (простое сравнение 32-битных целых чисел). Недостатком формата Unix-time в том что он не может отразить дополнительные високосные секунды [12], а также в том что он может отображать только даты в промежутке с 1901 по 2038 год. Также в январе 2038 года данный формат будет подвержен ошибке из-за переполнения 32-битного целого числа. Программа для управления РВ-90 работает лишь с текущим годом, плюс-минус 10 лет, поэтому в данной работе ошибка переполнения никак не обрабатывается. Что касается дополнительных високосных секунд, то с 1970 по 2007 их было 23 [13], поэтому за период эксплуатации устройства, составляющий ориентировочно 2 года ожидается что их влияние будет несущественно. Тем не менее программа предоставляет пользователю возможность синхронизировать время в РВ-90 с другим устройством с целью устранения ошибки в отсчете времени на РВ-90. Часы DS1374 также имеют возможность генерировать программируемое прерывание.
Прерывания в определенный момент времени можно использовать для максимально точного контроля реле. Однако, в такой точности нет необходимости поскольку текущее время с точностью до секунды можно отсчитывать центральным процессором. Поэтому часы используются для борьбы с небольшой плавающей ошибкой, для этого программа синхронизируется с часами один раз в час. Также часы используются для бесперебойного отсчета времени когда устройство РВ-90 не подключено к электропитанию, для этого часы имеют отдельное питание от батарейки. Надо учитывать что часы используют 32-битное знаковое целое число для счетчика и подвержены ошибке переполнения счетчика в 2038 году. В данной работе эта ошибка не обрабатывается.  
В качестве аналога к часам DS1374 имеются часы DS1672, которые практически идентичны за исключением возможности генерации прерывания. 
Программа не имеет функционала для работы с часами использующими представление времени в формате BCD (Binary Coded Decimal). Часы в формате BCD удобны для вывода времени, кроме того они корректно отсчитывают текущую дату и время, принимая в расчет високосные годы. В частности дополнительный день и секунды в високосный год, а также количество дней в каждом месяце в зависимости от текущего года. 
Пример часов работающих в формате BCD - DS1307, отличаются низкой ценой.


\subsubsection{ Wi-Fi модуль RАК473 }
Производства компании Rak-Wireless [14]. 
Существует аналогичный модуль компании FN-link F11AMIM13\_B1. RAK473 включает в себя микроконтроллер RTL8711AM от Realtek, флеш-память GD25Q16C размером в 2MB от GigaDevice подключаемую к микроконтроллеру через SPI интерфейс, Wi-Fi антенну, регуляторы и предохранители для GPIO пинов чипа. Блок схема модуля представлена на рисунке.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{rak473_block_diagram.png}
    \caption{Блок схема модуля.}
\end{figure}

У модуля имеются 19 GPIO. 
Выводы GPIOB0 и GPIOB1 используются для UART.
Выводы GPIOB2, GPIOB3 используются для подключения шины I2C.
Выводы GPIOE4, GPIOE3 используются для программирования.
Схема GPIO выводов модуля представлена на рисунке.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{rak473_pinout.png}
    \caption{Схема GPIO выводов модуля RAK473.}
\end{figure}

\subsubsection{ Микроконтроллер RTL8711AM}
В основе модуля RAK473 находится микроконтроллер производства компании Realtek[15]. Это одно-кристальный микропроцессор нацеленный для изделий Internet of Things. Он сочетает в себе ARM ядро на базе Cortex-M3, WLAN MAC и NFC в одном чипе. Тактовая частота процессора 166 MHz. 

Процессор имеет 1MB встроенной ROM памяти, 2.5 MB RAM памяти и SPI интерфейс для подключения Flash памяти.  В памяти ROM размещается заводской бутлоадер и некоторые функции для стандартной библиотеки. Данная память находится по адресам с 0х00000000 по 0х000FFFFF. Ей невозможно воспользоваться для разработки, т.к. ее невозможно перепрошить. Память RAM состоит из блока SRAM и блока SDRAM. SRAM (Static Random Access Memory) это статичная память, доступ к ячейкам данного типа памяти осуществляется быстрее чем к ячейкам памяти SDRAM (Synchronous Dynamic Random Access Memory), к тому же ее не надо периодически обновлять чтобы поддерживать правильные значения битов памяти. Однако она дороже т.к. требует большего количества транзисторов на один бит памяти. Поэтому в данном микроконтроллере память SRAM имеет всего лишь 448KB. SRAM расположена по адресам с 0х10000000 по 0х1006FFFF. Память SDRAM имеет 2 МB памяти. Доступ осуществляется по адресам с 0х30000000 по 0х301FFFFF.

При запуске микроконтроллер начинает с исполнения заводской программы, то есть загрузчика (bootloader) находящегося в ROM памяти. Загрузчик инициализирует некоторые внутренние значения и переходит к считыванию данных из подключенной флеш-памяти. Ожидается что память подключена по протоколу SPI к определенным пинам микроконтроллера. 
Ниже представлено разбиение флеш-памяти с которым ожидает работать загрузчик. Изображение ниже не является картой RAM памяти. 

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{rtl8711am_flash_layout.png}
    \caption{Разбиение флеш-памяти с которым должен работать загрузчик.}
\end{figure}

На схеме также показан "Upgraded Image 2", который используется для технологии обновления прошивки OTA (Over The Air). Данная программа не предусматривает возможности обновления прошивки по каналу Wi-Fi, поэтому область выделенная для "Upgraded Image 2" может быть использована для любых других нужд разработчика. В частности для хранения пользовательской информации.


Загрузчик поддерживает работу с форматом Binary Image File (.bin). Для того чтобы получить прошивку (файл типа .bin) которая будет правильно обработана загрузчиком следует использовать официальный SDK (Software Development Kit) от компании Realtek. Загрузчик читает данные из флеш-памяти и в соответствии с директивами формата ELF копирует данные в разные области RAM памяти. После этого загрузчик очищает свой стек и передает управление пользовательскому коду. Таким образом RTL8711AM не использует технологию XiP (Execute in Place), хотя она и является довольно распространенным решением.

\subsubsection{ Ядро ARM Cortex-M3}
В основе микроконтроллера RTL8711AM находится ядро ARM Cortex-M3. Это семейство процессоров, призванное занять новую для ARM нишу встраиваемых решений. В семействе присутствуют три значимых ядра[16].

\begin{my_enumerate}
\item Cortex-M0 с архитектурой ARMv6-M;
\item Cortex-M3 (опционально Memory Protection Unit) с архитектурой ARMv7-M;
\item Cortex-M4 (опционально Floating Point Unit) с архитектурой ARMv7E-M;
\end{my_enumerate}

Диаграмма ниже отображает какие подсистемы процессора реализуются по спецификации ARM, а какие по инициативе конкретных компаний, таких как Realtek.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{arm_vs_custom_modules.png}
    \caption{Разбиение реализации подсистем процессора.}
\end{figure}


Процессор использует Гарвардскую архитектуру, имеется отдельная шина инструкций и шина данных. Однако шины инструкции и данных используют единое пространство памяти. Поэтому общая память системы делится между данными и инструкциями. Процессор Cortex-M3 включает в себя ряд фиксированных внутренних компонентов отладки которые разрабатываются компанией ARM. Эти компоненты обеспечивают поддержку операций отладки и функции, такие как точки останова (breakpoints) и точки наблюдения (watchpoints).

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{cortex_m3_subsystems_overview.png}
    \caption{Подсистемы процессора Cortex-M3.}
\end{figure}


Функционал Trace отключен. Подсистема MPU (Memory Protection Unit) не поддерживается.
Процессор имеет два режима работы: Привилегированный и пользовательский режим. В данной работе используется только привилегированный режим. Cortex-M3 предоставляет стандартизированную схему разбиения адресов для разработчиков микроконтроллеров. Это важно для функционирования программы поскольку определяет способ для взаимодействия между программой на C и периферией процессора. В данном случае доступ к периферии производится обращением к определенным ячейкам памяти. Производители могут модифицировать схему разделов памяти. Как описано в разделе о границах RAM памяти Realtek немного модифицировал разбиения памяти. ROM память находится по адресам с 0х00000000 по 0х000FFFFF. SRAM расположена по адресам с 0х10000000 по 0х1006FFFF. Доступ к памяти SDRAM осуществляется по адресам с 0х30000000 по 0х301FFFFF.
 
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{predefined_memory_map.png}
    \caption{Разбиение памяти для микроконтроллера Cortex-M3.}
\end{figure}


Поддержка аппаратных прерываний осуществляется с помощью NVIC (Nested Vectored Interrupt Controller). Важными особенностями NVIC для функционирования программы являлось то что он поддерживает вектор прерываний (vectored interrupt support), вложенные прерывания на аппаратном уровне (nested interrupt support), программно устанавливаемые приоритеты для прерываний (dynamic priority changes support), маскировку прерываний (interrupt masking).


Процессор взаимодействует с периферией через несколько шин. Ниже представлена блок-схема подключения периферии включая шину для отладки внутри процессора.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{cortex_m3_peripherals_block_diagram.png}
    \caption{Блок-схема подключения периферии к шинам внутри процессора.}
\end{figure}


Процессор Cortex-M3 включает в себя функции отладки. Поддерживает JTAG или SW (Serial-Wire) интерфейс для внешнего отладчика. Технология реализующая подсистему отладки процессора - CoreSight. С ее помощью можно получить доступ к состоянию регистров процессора и содержимому ячеек памяти. Есть встроенная поддержка шести точек останова (breakpoints) и четырех точек наблюдения (watchpoints).

В Cortex-M3, доступ к функционалу для отладки расположенному на процессоре осуществляется через интерфейс шины DAP (Debug Access Port). DAP управляется другим компонентом известным как DP (Debug Port) который преобразует команды JTAG или SW (Serial-Wire) поступающие из внешнего отладчика в команду DAP и направляет ее на шину. Ниже приведены схема подключения отладчика к процессору, а также  схема взаимодействия компонентов отладки Cortex-M3. 


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{cortex_m3_debug_connection.png}
    \caption{Схема подключения отладчика к процессору Cortex-M3.}
\end{figure}


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{cortex_m3_inside_debug_subsystem.png}
    \caption{Схема взаимодействия компонентов отладки Cortex-M3.}
\end{figure}

.


\newpage

\subsection{Платформа Браузер}
На самом деле не следует рассматривать конкретный браузер как платформу для разработки. Следует рассматривать набор спецификаций которые суммарно определяют веб-платформу. Браузер лишь реализует данные спецификации и предоставляет разработчику доступ к конкретной реализации веб-платформы.

\subsubsection{ Организации выпускающие спецификации веб-платформы}
Стандарты публикуемые организацией W3C определяют основные компоненты веб-платформы. Границы веб-платформы продолжают развиваться. Краеугольным камнем веб-платформы является HTML5, однако функционал используемый в данной работе зависит от многих других спецификаций, которые создают W3C и другие организации. В частности CSS, SVG, WOFF, ECMAScript и различные браузерные API.

В разработке спецификаций которые определяют веб-платформу участвуют несколько организаций. Ниже перечислены ключевые организации публикующие стандарты которые определяют веб-платформу.

\begin{my_enumerate}
\item Рекомендации, опубликованные консорциумом World Wide Web Consortium (W3C) [17], такие как HTML / XHTML, каскадные таблицы стилей (CSS), объектная модель документа (DOM), форматы изображений, такие как портативная сетевая графика (PNG) и масштабируемая векторная графика (SVG), а также специальные технологии, такие как WOFF.
\item Стандарты, опубликованные Ecma International (ранее ECMA), такие как JavaScript (также известный как "стандартный ECMAScript")
\item Стандарты, опубликованные международной организацией по стандартизации (ISO), такие как JPEG.
\end{my_enumerate}


\subsubsection{ Спецификации определяющие веб-платформу}
Набор спецификаций определяющий веб-платформу позволяет разработчику абстрагироваться от конкретного браузера. Это существенно облегчает разработку веб-приложения которое должно работать в различных браузерах.

Когда веб-сайт или веб-приложение описываются как соответствующие стандартам веб-платформы или просто веб-стандартам, это означает, что сайт или приложение имеют допустимые стандартом HTML, CSS и JavaScript. HTML отвечает требованиям доступности для людей с нарушением зрения (дальнозоркостью или дальтонизмом) или движений, благодаря размещению специальных пометок и дополнительной информации на странице, а также другим семантическим рекомендациям. Полное соответствие стандарту охватывает также корректные параметры для кодирования символов, корректные метаданные, корректно сформированный XML, корректное встраивание скриптов и правильную настройку сервера.

Компонент программы который предназначен для исполнения в браузере, то есть для запуска на веб-платформе, требует для успешной работы чтобы браузер поддерживал следующие основополагающие спецификации описывающие веб-платформу.

\begin{my_enumerate}
\item Рекомендации для языков разметки, таких как язык разметки HTML (HyperText Markup Language) и масштабируемая векторная графика (Scalable Vector Graphics) из W3C.
\item Рекомендации для таблиц стилей, особенно каскадных таблиц стилей (Cascading Style Sheets), от W3C.
\item Стандарты для ECMAScript, чаще JavaScript, от Ecma International.
\item Рекомендации для объектных моделей документов (Document Object Model) от W3C.
\item Правильно сформированные имена и адреса для страницы и всех других ресурсов, на которые в ней есть ссылки (Uniform Resource Idenfirier), на основе RFC 2396, из IETF.
\item Правильное использование HTTP и MIME типов для скачивания веб-страницы, ее интерпретации и запроса других ресурсов, упомянутых в ней, на основе RFC 2616, из IETF.
\item Веб-доступность обычно основана на руководящих принципах доступности веб-контента, опубликованных инициативой W3C по веб-доступности.
\end{my_enumerate}

\subsubsection{ Реализация веб-платформы в различных браузерах}
При создании компонента программы для веб-платформы важно помнить что в итоге компонент должен будет запускаться на конкретной версии конкретного браузера на конкретном пользовательском устройстве (операционной системе).
Разработка компонента для браузера не тривиальна, в силу того что существует несколько популярных браузеров, у многих есть мобильные версии, у одного браузера есть несколько популярных устаревших версий браузера, и наконец для каждой операционной системы существует своя версия браузера. Каждая из этих мобильных или десктопных версий является своей обособленной реализацией веб-платформы. Каждая из этих мобильных или десктопных версий имеет свои уникальные ошибки и баги в реализации стандартов описывающих веб-платформу. Веб-разработчик сталкивается с проблемами дырявых абстракций (leaky abstractions)[18] в том как браузеры реализуют стандарты описывающие веб-платформу.


\subsubsection{ Поддерживаемые браузеры}
Из-за большого количества различных реализаций веб-платформы невозможно вести разработку нацеленную на правильную работу во всех браузерах. Необходимо выделить реальное подмножество на которое будет нацелена разработка из множества всех комбинаций версий, типов браузеров и версий, типов операционных систем.

При разработке компонента для запуска в браузере следует учитывать что после его интеграции в программу для управления и мониторинга РВ-90 у разработчика не будет возможности что-либо изменить в данном компоненте. В силу данного факта следует уделить уделить особое внимание правильному пониманию и использованию стандартов описывающих веб-платформу, а также следует стремиться максимально расширить множество поддерживаемых браузеров, чтобы охватить как можно больше наиболее распространенных версий.

Следует определить каким именно браузерам стоит уделить внимание при разработке. 
Для данной программы было решено ограничиться поддержкой браузеров которые имеют более 0.05\% рынка пользователей в России, при этом исключив из этого списка браузеры Internet Explorer версии 9 и раньше, а также браузер Opera mini. Для определения конкретных версий и названий браузеров, которые должны стать ключевыми при реализации были использованы проекты "Can i use" и "Browserlist".

Также не представлялось возможным осуществить поддержку каждой из всех 30 распространенных версий Gogole Chome и Firefox поэтому для тестирования были выбраны самые новые и самые старые из популярных версий каждого браузера.
Ниже приведен итоговый список поддерживаемых браузеров для программы управления и контроля РВ-90.

\textbf{Мобильные браузеры}
\begin{my_itemize}
\item Chrome for Android 73
\item Firefox for Android 66
\item UC Browser for Android 11.8
\item Android Browser 4.4
\item Android Browser 4
\item IE Mobile 11
\item iOS Safari 12
\item iOS Safari 8
\item Samsung Internet 9.2
\item Samsung Internet 7
\end{my_itemize}

\textbf{Десктопные браузеры}
\begin{my_itemize}
\item Chrome 74
\item Chrome 52
\item Firefox 66
\item Firefox 48
\item Edge 18
\item IE 10
\item Opera 58
\item Opera 39
\item Safari 12
\item Safari 9
\end{my_itemize}

С аппаратной точки зрения также следует помнить что размер окна браузера меняется в зависимости от настроек пользователя. Поэтому компонент должен поддерживать адаптивный интерфейс  корректно работающий при разных размерах экрана.  На данный момент браузеры на других платформах как например умные часы или умный телевизор не являются официально поддерживаемыми. Приведенные выше браузеры являются поддерживаемыми платформами для работы одно-страничного веб-приложения являющимся одним из трех компонентов программы для управления РВ-90.


\newpage
\subsection{Платформа Android}
Приложения для платформы Android запускаются в виртуальной машине Java, которая предоставляет абстракцию от аппаратной базы устройства.

Android предназначен для работы на различных видах устройств, от телефонов до планшетов и телевизоров. 
Приложение для Android гарантированно совместимо со всеми устройствами Android, однако может быть не совместимо с конкретной конфигурацией устройства. Например, некоторые устройства могут не иметь  Wi-Fi соединения. Если основные функции приложения требуют использования наличие Wi-Fi соединения, приложение совместимо только с устройствами, которые имеют возможность устанавливать соединение по сети Wi-Fi. Приложение может быть совместимо с телефоном и планшетом, но не совместимо с умным телевизором.
Android предоставляет возможность создать отдельный APK (Android Package) для различных конфигураций устройства. В рамках данной работы планируется разрабатывать только один APK (Android Package) который будет удовлетворять конфигурациям наибольшего количества устройств. 

Компонент программы предназначенный для работы на платформе Android, должен работать лишь на планшетах и телефонах. С точки зрения реализации отличие планшетов от телефонов заключается лишь в разных конфигурациях экрана.

Ниже перечислены параметры конфигурации приложения которые влияют на ограничение доступности приложения для устройств через Google Play Store.  
Соответственно данные параметры определяют более конкретную конфигурацию для платформы Android на которой будет запускаться третий компонент программы.

\begin{my_enumerate}
\item Особенности устройства
\item Версия платформы
\item Конфигурация экрана
\end{my_enumerate}

\subsubsection{Особенности устройства}
Чтобы управлять доступностью приложения на основе функционала самого устройства, Android определяет идентификаторы функций для любого оборудования или программного обеспечения, которые могут быть недоступны на устройствах. Например, идентификатор функции для датчика компаса - FEATURE\_SENSOR\_COMPASS, а идентификатор функции для виджетов приложений-FEATURE\_APP\_WIDGETS.
При необходимости можно запретить пользователям установку приложения, если их устройства не предоставляют данную функцию, объявив ее с элементом <uses-feature> в файле манифеста приложения.
Компонент для Android не требует наличия нестандартной функциональности, поэтому проект не пользуется данным ограничением.

\subsubsection{Версия платформы}
На разных устройствах могут работать разные версии платформы Android, такие как Android 4.0 или Android 4.4. Каждая последующая версия платформы часто добавляет новые API, недоступные в предыдущей версии. Чтобы указать, какой набор API, каждая версия платформы задает уровень API. Например, Android 1.0-это уровень API 1, а Android 4.4-уровень API 19.
Уровень API позволяет объявить минимальную версию, с которой совместимо приложение, используя тег манифеста <uses-sdk> и его атрибут minSdkVersion. Например, API поставщика календаря были добавлены в Android 4.0 (уровень API 14). Если приложение не может работать без этих API, следует объявить уровень API 14 минимальной поддерживаемой версией приложения.

Атрибут minSdkVersion объявляет минимальную версию, с которой совместимо приложение, а атрибут targetSdkVersion объявляет самую высокую версию, на которой оптимизировано приложение.
Для реализации данного компонента была выбрана настройка minSdkVersion = 15, а targetSdkVersion = 22. Данные настройки для минимальной версии SDK гарантируют что приложение будет работать на более чем 95\% процентах устройств подключающихся к Google Play Store. targetSdkVersion намеренно выставлено столь низко чтобы обойти проблему динамического запроса разрешений пользователя на использование определенных API, вместо этого запрос на разрешение выполняется в процессе установки приложения из Google Play Store [19].

\subsubsection{Конфигурация экрана}
Android работает на устройствах различных размеров, от телефонов до планшетов и телевизоров. Чтобы классифицировать устройства по типу экрана, Android определяет две характеристики для каждого устройства: размер экрана (физический размер экрана) и плотность экрана (физическая плотность пикселей на экране, известная как DPI или Dots Per Inch). Чтобы упростить различные конфигурации, Android обобщает эти варианты в группы, которые облегчают их использование.

Четыре обобщенных размера: 
\begin{my_enumerate}
\item small (маленький)
\item normal (нормальный)
\item large (большой)
\item xlarge (очень большой)
\end{my_enumerate}

И несколько обобщенных плотностей: 
\begin{my_enumerate}
\item mdpi (средняя)
\item hdpi (высокая)
\item xhdpi (очень высокая)
\item xxhdpi (экстра-экстра высокая)
\end{my_enumerate}

По умолчанию приложение совместимо со всеми размерами и плотностями экрана, поскольку система вносит необходимые изменения в макет пользовательского интерфейса и ресурсы изображений по мере необходимости для каждого экрана.

В данной работе компонент никак не ограничивает ни размер, ни плотность экрана.



%===========================================================================



\newpage
\subsection{Архитектура прошивки для РВ-90}
% what is it
% what it does
Прошивкой является файл типа .bin который прошивается во флеш-память находящуюся на модуле RAK473.

Прошивка осуществляет контроль за периферией реле и является основным компонентом программы.

Ниже изображена блок схема компонент прошивки, на которой отражены активные потоки системы. Каждая пользовательская библиотека и поток представляют собой отдельный модуль системы. На диаграмме разбиение на пользовательские и системные модули, разделяет модули которые поставлялись в комплекте с SDK от модулей которые реализованы в данной работе.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{firmware_modules_diagram.png}
    \caption{Блок схема отображающая модули прошивки.}
\end{figure}

Для организации работы используются потоки FreeRTOS. Поток - это абстракция предоставляемая FreeRTOS, которая используется для организации работы системы и контроля за доступам к ресурсам и периферии системы. Каждый поток предельно прост и призван выполнять только одну функцию, однако самих потоков довольно много. Чтобы модули потоков были наиболее просты для понимания и поддержки, как можно больший пласт функций находится в пользовательских библиотеках, которые выделены в отдельные модули. В результате данной архитектуры в системе есть много простых потоков которые используют сложные схемы для синхронизации и взаимодействия. Все потоки кроме потока LwIP работают по схеме: проснуться, проверить наличие работы, поработать, поставить таймер и заснуть на некоторый интервал времени. Поток LwIP является потоком по умолчанию который работает когда все остальные задачи спят. Потоки взаимодействуют друг с другом через примитивы синхронизации, а именно семафоры и очереди.

В частности прошивка создает и поддерживает точку доступа к сети Wi-Fi. Что снижает риск безопасности, связанный с распространением информации через Интернет. 
Прошивка устанавливается на РВ-90 при производстве устройства. Код входящий в прошивку разбит на несколько модулей. Модули разделены на основе функциональности, которая должна присутствовать в реле времени.


\subsubsection{ Прошивка для РВ-90 }
Файл прошивки получается на последнем этапе компиляции, посредством обработки EFL (Executable and Linkable Format, Extensible Linking Format) файла программы. 
Файл Bin - это чистый двоичный файл без исправлений памяти или перемещений, он требует загрузки по определенному адресу памяти.
Файлы ELF - это более сложный формат, состоящий из секций не все из которых предназначены для загрузки в RAM память. Формат включает в себя таблиц для поиска символов и таблицы перемещений. Он предназначается для загрузки операционной системой по произвольному адресу памяти, адреса переменных в этом случае вычисляются во время выполнения используя таблицу GOT (Global Offset Table). 

Ниже представлена схема сборки прошивки с помощью официального SDK от Realtek и GNU GCC ARM Toolchain.
 
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{compilation_steps_firmware.png}
    \caption{Этапы сборки прошивки РВ-90.}
\end{figure}

К данному процессу стоит добавить этап после получения .bin файла, а именно сборку образа файловой системы в которой хранится веб-компонент программы. А также объединение образа файловой системы и прошивки в единый образ прошивки. 


\begin{figure}[h!]
    \centering
    \includegraphics[width=1.0\textwidth]{from_firmware_to_ram.png}
    \caption{Код в файле прошивки, во флеш-памяти и наконец при загрузке в RAM.}
\end{figure}


\subsubsection{ Описание архитектуры модулей}
Для организации работы и разделения ресурсов периферии используется модуль FreeRTOS. 
FreeRTOS - предоставляет ядро операционной системы реального времени для встроенных устройств. FreeRTOS разработан с целью создания простой и компактной в плане использования RAM операционной системы. Само ядро состоит только из трех C-файлов. Чтобы сделать код читаемым, легко портируемым и поддерживаемым, он написан в основном на C, но там, где это необходимо, есть несколько ассемблерных функций (в основном в подпрограммах для планировщика архитектуры).

FreeRTOS предоставляет методы для создания потоков (task), примитивов синхронизации, таких как мьютекс (mutex), семафор (semaphore), а также программных таймеров. Потокам можно назначать разные приоритеты. FreeRTOS предоставляет свой аллокатор памяти, объекты RTOS могут быть динамически распределены с помощью пяти схем выделения памяти:

\begin{my_enumerate}
\item heap\_1 - самая простая, не позволяет освобождать память.
\item heap\_2 - позволяет освободить память, но не производит объединения соседних свободных блоков.
\item heap\_3 - обертка вокруг стандартных malloc() и free() для безопасности обращения из потоков.
\item heap\_4 - производит объединения соседних свободных блоков чтобы избежать фрагментации.
\item heap\_5 - также как и heap\_4, с возможностью работать с heap который распределен на нескольких не смежных областей памяти.
\end{my_enumerate}

Модуль для управления выходом реле (включено-выключено).
Данный модуль периодически проверяет очередь событий и если в ней есть событие на включение или выключение реле, то модуль приводит его в действие. Для этого он запрашивает доступ к I2C шине и передает команду I2C расширителю портов PCA9555 на выключение или включение пина к которому подключено одно из двух реле. Для определения номера необходимого пина модуль обращается к модулю config. 

Модуль для TCP/IP потока LwIP. Он ждет приходящих пакетов на ранее зарегистрированный интерфейс, или просматривает очередь на наличие пакетов ожидающих отправки через определенный ранее зарегистрированный интерфейс.

Модуль управления DHCP сервером получает DHCP пакеты от модуля TCP/IP потока LwIP, обрабатывает их и выдает ответ. Модуль следит за набором доступных IP адресов.

Модуль управления HTTP сервером получает HTTP запросы от модуля TCP/IP потока LwIP, интерпретирует их с помощью модуля HTTPD, обрабатывает их и либо обращается к модулю HTTP API для генерирования ответа, либо обращается к модулю SPIFFS для передачи в ответ на запрос файла из файловой системы. 

Модуль вывода отладочной информации.
Предоставляет набор функций и макросов для контроля над дебаг информацией передаваемой по UART.

Модуль для генерации ответа HTTP API предоставляет набор шаблонов для генерации стандартных ответов HTTP сервера. Также модуль может обращаться к файловой системе для чтения или записи новых настроек поступивших от пользователя, и к модулю генерации и интерпретации JSON для работы с запросами.

Модуль для анализа и генерации JSON.
Предоставляет функции для интерпретации и генерации JSON строки из переменных языка C.

Модуль для управления коммуникацией по протоколу I2C, предоставляет альтернативную реализацию протокола I2C вместо неправильно реализованной версии в официальном SDK от Realtek.

Модуль для связи с чипом DS1307 предоставляет набор команд для настройки и чтения текущего времени, а также для настройки таймера аппаратного прерывания, расположенного в чипе DS1374. Все взаимодействие происходит через протокол I2C.

Модуль управления временем системы раз в час синхронизирует внутренний счетчик системы со счетчиком расположенным в DS1374.

Модуль управления файловой системой предоставляет доступ к чтению и записи файлов файловой системы, одновременно предоставляя защиту от одновременного доступа нескольких потоков. 


\subsubsection{ Официальный SDK от Realtek}
На самом деле сложно разграничить официальный SDK от пользовательского кода, т.к. при сборке проекта обе части собираются вместе.
Между кодом SDK и пользовательским кодом образуется взаимосвязь, так как некоторые аспекты платформы приходится настраивать в самом SDK.

SDK имеет сравнительно мало закрытых бинарных библиотек. Многие закрытые функции содержаться в ROM памяти микроконтроллера. 
При соотношении полученных на выходе команд ассемблера можно сказать что 70\% SDK это открытый исходный код. Наличие большого объема открытого кода позволяет существенно уменьшить SDK при этом не теряя функциональности для программы управления РВ-90.   

Официальный SDK имеет довольно запутанную структуру. Причина отчасти в том что SDK поддерживает одновременно две различных аппаратных платформы Ameba-Zero и Ameba-One. Ameba - это название аппаратной платформы для разработки решений в сфере IoT (Internet of Things) от компании Realtek. Ameba-Zero использует микроконтроллер RTL8710. Аmeba-One использует микроконтроллер RTL8195 который совместим с микроконтроллером RTL8711AM, но предоставляет больше функций.

Для упрощения работы с SDK из него были выкинуты файлы использующиеся лишь при сборки проектов Ameba-Zero.


\subsubsection{ Разбор кода предоставляемого компанией ARM}
Вместе с ядром ARM предоставляет стандарт CMSIS  (Cortex Microcontroller Software Interface Standard).
CMSIS предоставляет интерфейс на языке C который реализуется производителями микроконтроллеров, в частности компанией Realtek, для предоставления доступа из языка С к определенным функциям, которые есть на всех процессорах Cortex-M. Для программы контроля и управления РВ-90, важно что данный интерфейс предоставляет функции для доступа к регистрам, NVIC, определения частоты процессора.

Вместе с ядром ARM также предоставляет стандарт Mbed API.
Mbed - это набор библиотек для упрощения разработки подключенных к интернету устройств на базе 32-разрядных микроконтроллеров ARM Cortex-M. Проект совместно разрабатывается ARM, партнерами и волонтерами от сообщества mbed. Код разрабатывается под лицензией Apache 2.0. Он включает в себя все основные программные компоненты для встроенных систем, такие как операционную систему, TCP/IP стек, а также множество портов HAL (Hardware Abstraction Layer), которые позволяют mbed работать на микроконтроллерах с ядром Cortex-M от разных производителей практически без изменения пользовательского кода.
Mbed предоставляет интерфейс на языке C который реализуется производителями микроконтроллеров, в частности компанией Realtek, для предоставления доступа из языка С к периферии микроконтроллера, а также к большому набору функций описанных в спецификации Mbed API, таких как реализация ОС и TCP/IP стека. 

Mbed API в данной работе не используется. Вместо этого для контроля периферии напрямую используются функции предоставляемые компанией Realtek. Mbed предоставляет дополнительный уровень абстракции поверх FreeRTOS и LwIP. Вместо того чтобы использовать данный уровень абстракции, обращение к функционалы FreeRTOS и LwIP происходит напрямую. Это сделано чтобы существенно уменьшить размер прошивки на флеш-памяти и при загрузке в RAM, позволяя освободить память для файлов веб-компонента и пользовательских настроек. 


\newpage
\subsection{Архитектура одно-страничного веб-приложения для браузера}
% what is it
% what it does
Одно-страничное веб-приложение храниться во флеш-памяти микроконтроллера в виде набора файлов и передается на подключенное устройство пользователя когда пользователь инициирует запрос корневого документа.

Пользовательский интерфейс к реле реализован в веб-приложении. Веб-приложение позволяет пользователю отследить и изменить состояние реле. Включая изменение состояния, контактов, изменение названия и пароля Wi-Fi сети, изменение текущего времени системы. Также веб-приложение позволяет пользователю составить программу включений и выключений на 2 года вперед, и передает данную программу на РВ-90.

Архитектура для веб-приложения предельно проста. Корневой файл index.html предоставляет все элементы которыми будут манипулировать Javascript и CSS модули. Два модуля constants.js и globals.js используются для объединения DOM описанном в index.html с другими модулями. Три модуля CSS определяют вид приложения.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{webapp_modules_blocks.png}
    \caption{Блок схема отображающая модули одно-страничного веб-приложения.}
\end{figure}

\subsubsection{ Загрузка и запуск компонента}
При подключении пользователь запрашивает корневой файл, в ответ HTTP сервер возвращает index.html
Вместе с ним загружается основной файл стилей CSS и Javascript модуль connections.js для динамической загрузки в бекграунд процессе остальных файлов. Остальными файлами являются дополнительные стили CSS и модули Javascript содержащие функции манипулирования DOM в index.html, и в частности модуль для создания расписания включений и выключений fullcalendar.js  

\subsubsection{ Кросс-браузерное тестирование}
Веб-разработчик сталкивается с проблемами дырявых абстракций в том как браузеры реализуют стандарты описывающие веб-платформу, поэтому при реализации требуется проводить кросс-браузерное тестирование.
Разработка и тестирование компонента для браузера не тривиальна, в силу того что 
существует несколько популярных браузеров, у многих есть мобильные версии, у одного браузера есть несколько популярных версий браузера, для каждой операционной системы существует своя версия браузера. Каждая из этих мобильных или десктопных версий является своей обособленной реализацией веб-платформы. Каждая из этих мобильных или десктопных версий имеет свои уникальные ошибки и баги в реализации стандартов описывающих веб-платформу. 

Из-за большого количества различных реализаций веб-платформы в браузерах кросс-браузерное тестирование на реальных комбинациях версий, типов и операционных систем является необходимым этапом разработки. При разработке компонента для запуска в браузере следует учитывать что после его интеграции в программу для управления и мониторинга РВ-90 у разработчика не будет возможности что-либо изменить в данном компоненте. Поэтому при разработке компонента для исполнения в браузере следует уделить особое внимание правильному пониманию и использованию стандартов описывающих веб-платформу, а также кросс-браузерному тестированию. 

\subsubsection{ Описание архитектуры модулей}
Веб-приложение можно разложить на следующие модули.

Модуль для взаимодействия с сервером через AJAX подгружает в бекграунде дополнительные CSS и Javascript модули, а также предоставляет простой интерфейс для отправки запросов к серверу и получению ответов. Интерфейс основан на   (callbacks).

Модуль для отображения состояния реле показывает текущее состояние внутренних параметров РВ-90. Модуль также следит за своевременным и консистентным обновлением веб-интерфейса.

Модуль для настройки включений и выключений реле предоставляет тот же функционал который можно встретить в других электронных реле времени. Оператор может: создать новый цикл включения/выключения и дать ему имя, назначить цикл определенному дню и установить его на повторение еженедельно или ежемесячно, установить исключения и переопределить циклы в определенные дни, получить обзор того, какие циклы выполняются в какие дни. Интерфейс интуитивно понятен и прост в использовании.

Модуль constants.js  содержит настройки для веб-приложения.

Модуль reset.css содержит инструкции для того чтобы привести стили которые браузеры выставляют по умолчанию к единому знаменателю.

Модуль index.css непропорционально велик по сравнению с другими CSS модулями, однако он содержит фактически все стили необходимые для правильной рисовки страницы.

Модуль spritesheet.css содержит координаты для каждой иконки в обшей карте иконок.


\newpage
\subsection{Архитектура мобильного приложения для Android}
% what is it
% what it does
Мобильное приложение представляет собой APK (Android Package) файл. Потенциально приложение может быть размещено в Google Play Store и доступно для установки на устройства Android.

Приложение позволяет предоставить пользователям более обширный функционал по сравнению с одно-страничным веб-приложением, за счет того что приложение позволяет более тесное взаимодействие с системой чем браузер. В частности приложение не имеет существенного ограничения по размеру устанавливаемого файла, в отличие от веб-интерфейса.

На данном этапе приложение предоставляет более удобный и дружелюбный для пользователя интерфейс создания календаря включений и выключений. Приложение является полностью опциональным компонентом системы и пользователю не требуется устанавливать его для того чтобы эксплуатировать реле по назначению.

Ниже представлена блок схема модулей приложения.



\subsubsection{ Описание архитектуры модулей}
Все модули приложения можно отнести к одной из 4 групп. Модули из группы Activity отвечают за различные экраны приложения, рисовку и логику взаимодействия элементов интерфейса. Модули из группы Controls реализуют новые элементы интерфейса для платформы Android которых не хватает в стандартной библиотеке. Модули из группы Netrowking отвечают за соединение с сервером РВ-90, сериализацию/десериализацию и прием/передачу данных. Наконец модули из группы DataModel реализуют бизнес сущности, то есть календарь (Calendar) состоит из циклов (Cycle), цикл состоит из временных отрезков (Timestrip). 
Ниже представлена блок схема модулей приложения.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{mobile_module_blocks.png}
    \caption{Блок схема модулей приложения.}
\end{figure}

Нижеследующие модули реализуют какой либо экран приложения используя Activity. 
MainApplication открывается первым при запуске приложения. 
CalendarOverviewActivity позволяет пользователю просмотреть календарь на один год с возможностью точно видеть какой цикл запускается в какие дни.
CycleCalendarActivity позволяет пользователю посмотреть в какие дни работает конкретный цикл.
CycleEditActivity позволяет пользователю редактировать временные отрезки включения и выключения одного цикла.
CycleNameActivity позволяет пользователю задать для цикла название и цвет для отображения на календаре.
ManageCalendarsActivity позволяет пользователю создавать и удалять календари.
ManageCyclesActivity позволяет пользователю создавать и удалять циклы. Циклы не привязываются к календарю при создании.
SelectDeviceWifiActivity позволяет пользователю настроить Wi-Fi соединение с РВ-90.

Нижеследующие модули реализуют новые элементы интерфейса которые необходимы для приложения и которых нет в стандартной библиотеке Android.  
CalendarControl реализует элемент для компактного отображения календаря на один год.
CalendarIconControl реализует элемент для отображения иконки календаря.
ClockOverlay реализует элемент для отображения цикла и временных отрезков.
CycleControl реализует элемент совмещающий отображение циклов с отображением названия и цвета цикла.
TimeStripControl реализует элемент для отображения и редактирования временного отрезка.

Нижеследующие модули реализуют функционал для взаимодействия с HTTP сервером.  
GsonDateSerializer сериализует тип Datetime в строку формата JSON, т.к. по умолчанию данный тип не имеет представления в JSON формате.
GsonFactoryBuilder создает инстанцию для сериализации и десериализации JSON в соответствии с пользовательскими настройками.
NetworkTaskInfo содержит информацию для подключения к РВ-90. 
RelayServerAPI содержит декларативное описание HTTP API.
TaskGetRelayCalendarData реализует запрос HTTP GET для информации о календаре и циклах.
TaskPingServer реализует запрос на проверку соединения.
TaskPostRelayCalendarData реализует запрос HTTP POST на загрузку новых настроек в РВ-90.




%===========================================================================



\newpage
\subsection{Взаимодействие между модулями прошивки}
Диаграмма ниже показывает какие модули знают о каких других модулях. Если модуль является библиотекой, как например в случае с модулем JSON, то обращение к нему будет приходить через вызов функции. Иначе, если модуль является потоком, то обращение к нему будет происходить через примитивы синхронизации, то есть через семафор или очередь.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{firmware_module_hierarchy.png}
    \caption{Взаимодействие между модулями прошивки.}
\end{figure}


\newpage
\subsection{Взаимодействие между модулями одно-страничного веб-приложения}
Диаграмма ниже показывает какие модули знают и используют функционал объявленный в других модулях. В данной компоненте не принимались меры по ограничению взаимодействия между модулями. Каждому модулю доступны все объявления функций и переменных в том модуле с которым он связывается.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{webapp_modules_hierarchy.png}
    \caption{Взаимодействие между модулями одно-страничного веб-приложения.}
\end{figure}


\newpage
\subsection{Взаимодействие между модулями мобильного приложения}
Диаграмма ниже показывает какие модули знают и используют функционал объявленный в других модулях. В рамках Android модули общаются либо прямым вызовом функций либо через запуск Intent.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1.03\textwidth]{mobile_modules_hierarchy.png}
    \caption{Взаимодействие между модулями мобильного приложения.}
\end{figure}


%===========================================================================


\newpage
\subsection{Взаимодействие между тремя компонентами программы}
Центральным компонентом является прошивка РВ-90. Она создает точку доступа и запускает HTTP сервер. Веб-приложение и мобильное приложение взаимодействуют с сервером.
Веб-приложение может либо обращаться к HTTP API, либо запрашивать файлы из файловой системы расположенной на флеш-памяти модуля RAK473. Мобильное приложение использует только HTTP API, т.к. вся информация для отображения интерфейса предоставляется вместе с APK.
HTTP API поддерживает несколько типов запросов. Планировалось сделать данное API как можно проще, чтобы избежать проблем с рассинхронизацией состояния между РВ-90 и тем состоянием которое отображается на устройстве пользователя. Самой частый вызов к API это "GET /read" который возвращает текущее состояние системы, а именно состояние контактов реле, текущее время, время следующего срабатывания для каждого реле, код состояния чипа реального времени, название сети Wi-Fi, пароль сети Wi-Fi, количество устройств подключенных к сети Wi-Fi на данный момент, состояние управления реле (ручное или автоматическое). Также присутствует "POST /set" принимающий запрос аналогичный "/read" но с желаемыми значениями. Также для того чтобы уменьшить нагрузку на Wi-Fi канал и уменьшить объем используемой RAM памяти для приема и передачи календаря, циклов, и временных отрезков используется не JSON, а бинарный формат.



%===========================================================================


\newpage
\subsection{Выводы по главе}
Разобрана общая трехкомпонентная архитектура программы. С аппаратной точки зрения описаны платформы на которых будут исполнятся компоненты программы. Описана архитектура каждого компонента и назначение каждого из их модулей. Разобрана модель взаимодействия между модулями внутри каждого компонента.
Описана модель взаимодействия между тремя компонентами программы.

